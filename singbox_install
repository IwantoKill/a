#!/bin/bash

# ==================================================
# Sing-box 全能一键安装脚本 (VLESS/VMess/TUIC/Shadowsocks)
# 支持: Docker/Node环境, 自动证书生成, DNS定制
# 本脚本在原有逻辑基础上增加：生成可被 v2rayN 一键导入的链接（vmess/vless/shadowsocks）
# 若使用 IP 模式（未提供域名），会通过 ifconfig.me / ipinfo.io / icanhazip.com 获取公网 IP
# ==================================================

# --- 默认变量 ---
SB_VERSION="1.12.13"
INSTALL_PATH="/usr/local/bin/sing-box"
CONFIG_PATH="/etc/sing-box"
CONFIG_FILE="${CONFIG_PATH}/config.json"
CERT_Path="${CONFIG_PATH}/cert"

# 默认参数
NODE_TYPE="vless"       # 默认协议
PORT=4433               # 默认端口
LISTEN_IP="::"          # 监听所有 IP
SERVER_DOMAIN=""        # 域名
DNS_SERVER=""           # DNS 服务器 (空则不配置)
ENABLE_TLS=false        # VMess 是否启用 TLS
WS_PATH="/ws"           # VMess WebSocket 路径

# 颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m'

# --- 1. 参数解析 ---
# -d: 域名
# -t: 类型 (vless, vmess, tuic, shadowsocks)
# -p: 端口
# -v: 版本
# -D: DNS地址 (例如 1.1.1.1)
# -s: 开启 VMess 的 TLS (开关量，不需要值)
while getopts "d:t:v:p:D:s" opt; do
  case $opt in
    d) SERVER_DOMAIN=$OPTARG ;;
    t) NODE_TYPE=$OPTARG ;;
    v) SB_VERSION=$OPTARG ;;
    p) PORT=$OPTARG ;;
    D) DNS_SERVER=$OPTARG ;;
    s) ENABLE_TLS=true ;;
    \?) echo "无效参数: -$OPTARG"; exit 1 ;;
  esac
done

# 如果没有域名，尝试获取公网 IP
if [ -z "$SERVER_DOMAIN" ]; then
    echo -e "${YELLOW}[Info] 未提供域名，尝试获取公网 IP 作为服务器地址${NC}"
    # 尝试多个服务（按顺序）
    PUBLIC_IP=""
    for svc in "https://ifconfig.me" "https://ipinfo.io/ip" "https://icanhazip.com"; do
        PUBLIC_IP=$(curl -s --max-time 5 "$svc")
        if [ -n "$PUBLIC_IP" ]; then
            break
        fi
    done

    if [ -n "$PUBLIC_IP" ]; then
        SERVER_DOMAIN="$PUBLIC_IP"
        IS_CUSTOM_DOMAIN=false
        echo -e "${GREEN}[Info] 检测到公网 IP: ${SERVER_DOMAIN}${NC}"
    else
        # 回退到原脚本的行为（用于 Reality 偷取）
        SERVER_DOMAIN="www.microsoft.com"
        IS_CUSTOM_DOMAIN=false
        echo -e "${YELLOW}[Warning] 无法从外部服务获取公网 IP，回退到默认域名占位: ${SERVER_DOMAIN}${NC}"
    fi
else
    IS_CUSTOM_DOMAIN=true
    echo -e "${GREEN}[Info] 使用域名: ${SERVER_DOMAIN}${NC}"
fi

# --- 2. 环境检查与安装 ---
install_depend() {
    echo -e "${GREEN}[Step 1] 检查并安装依赖...${NC}"
    if command -v apt-get >/dev/null; then
        apt-get update -y && apt-get install -y curl wget tar openssl
    elif command -v apk >/dev/null; then
        apk add --no-cache curl wget tar openssl ca-certificates
    elif command -v yum >/dev/null; then
        yum install -y curl wget tar openssl
    else
        echo -e "${RED}[Error] 未知系统，请手动安装 curl, tar, openssl${NC}"
        exit 1
    fi
}

if ! command -v curl >/dev/null || ! command -v tar >/dev/null || ! command -v openssl >/dev/null; then
    install_depend
fi

# --- 3. 下载 Sing-box ---
echo -e "${GREEN}[Step 2] 下载 Sing-box v${SB_VERSION}...${NC}"
ARCH="amd64"
DOWNLOAD_URL="https://github.com/SagerNet/sing-box/releases/download/v${SB_VERSION}/sing-box-${SB_VERSION}-linux-${ARCH}.tar.gz"

mkdir -p ${CONFIG_PATH}
mkdir -p ${CERT_Path}

if [ ! -f "${INSTALL_PATH}" ]; then
    curl -L -o sing-box.tar.gz "${DOWNLOAD_URL}"
    tar -xzf sing-box.tar.gz
    mv sing-box-${SB_VERSION}-linux-${ARCH}/sing-box ${INSTALL_PATH}
    chmod +x ${INSTALL_PATH}
    rm -rf sing-box.tar.gz sing-box-${SB_VERSION}-linux-${ARCH}
fi

# --- 4. 辅助函数：证书生成 ---
# 用于 TUIC 或 VMess+TLS 在没有现成证书的情况
generate_self_signed_cert() {
    local key_file="${CERT_Path}/private.key"
    local cert_file="${CERT_Path}/cert.pem"
    
    # 只有当文件不存在时才生成，避免覆盖
    if [ ! -f "$key_file" ]; then
        echo -e "${YELLOW}[Info] 生成自签名证书 (用于 TUIC/VMess-TLS)...${NC}"
        openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout "$key_file" -out "$cert_file" -days 3650 -subj "/CN=${SERVER_DOMAIN}" 2>/dev/null
    fi
}

# --- 5. 构建配置 JSON 片段 ---

# 通用 UUID/Password
UUID=$(${INSTALL_PATH} generate uuid)
PASSWORD=$(${INSTALL_PATH} generate rand --base64 16)

# DNS 配置块
DNS_CONFIG=""
if [ ! -z "$DNS_SERVER" ]; then
    DNS_CONFIG="\"dns\": { \"servers\": [{\"tag\": \"google\", \"address\": \"${DNS_SERVER}\", \"detour\": \"direct\"}], \"rules\": [] },"
    echo -e "${GREEN}[Info] DNS 已配置为: ${DNS_SERVER}${NC}"
fi

# --- 辅助: URL encode & base64 helper ---
urlencode() {
  local raw="$1"
  if command -v python3 >/dev/null 2>&1; then
    python3 -c "import sys,urllib.parse; print(urllib.parse.quote(sys.argv[1], safe=''))" "$raw"
  elif command -v python >/dev/null 2>&1; then
    python -c "import sys,urllib; print urllib.quote(sys.argv[1])" "$raw"
  else
    # 最小替换以避免不可导入字符
    echo -n "$raw" | sed -e 's/ /%20/g' -e 's/+/%2B/g' -e 's/@/%40/g' -e 's/:/%3A/g' -e 's/\//%2F/g'
  fi
}

b64() {
  # 把输入字符串 base64 后去掉换行，兼容各种系统
  echo -n "$1" | base64 | tr -d '\n'
}

# 入站配置块 (Inbound)
INBOUND_JSON=""

case $NODE_TYPE in
    "vless")
        # VLESS + Reality (最简便，无需自签证书)
        KEYS=$(${INSTALL_PATH} generate reality-keypair)
        PRIVATE_KEY=$(echo "$KEYS" | grep "Private" | awk '{print $3}')
        PUBLIC_KEY=$(echo "$KEYS" | grep "Public" | awk '{print $3}')
        SHORT_ID=$(${INSTALL_PATH} generate rand --hex 8)
        
        INBOUND_JSON=$(cat <<EOF
        {
            "type": "vless",
            "tag": "vless-in",
            "listen": "${LISTEN_IP}",
            "listen_port": ${PORT},
            "users": [{ "uuid": "${UUID}", "flow": "xtls-rprx-vision", "name": "user1" }],
            "tls": {
                "enabled": true,
                "server_name": "${SERVER_DOMAIN}",
                "reality": {
                    "enabled": true,
                    "handshake": { "server": "${SERVER_DOMAIN}", "server_port": 443 },
                    "private_key": "${PRIVATE_KEY}",
                    "short_id": ["${SHORT_ID}"]
                }
            }
        }
EOF
)
    ;;
    
    "vmess")
        # VMess + WS + (Optional TLS)
        TLS_JSON=""
        if [ "$ENABLE_TLS" = true ]; then
            generate_self_signed_cert
            TLS_JSON=$(cat <<EOF
            , "tls": {
                "enabled": true,
                "certificate_path": "${CERT_Path}/cert.pem",
                "key_path": "${CERT_Path}/private.key"
            }
EOF
)
        fi
        
        INBOUND_JSON=$(cat <<EOF
        {
            "type": "vmess",
            "tag": "vmess-in",
            "listen": "${LISTEN_IP}",
            "listen_port": ${PORT},
            "users": [{ "uuid": "${UUID}", "name": "user1" }],
            "transport": {
                "type": "ws",
                "path": "${WS_PATH}"
            }
            ${TLS_JSON}
        }
EOF
)
    ;;
    
    "tuic")
        # TUIC V5 (必须 TLS)
        generate_self_signed_cert
        INBOUND_JSON=$(cat <<EOF
        {
            "type": "tuic",
            "tag": "tuic-in",
            "listen": "${LISTEN_IP}",
            "listen_port": ${PORT},
            "users": [{ "uuid": "${UUID}", "password": "${PASSWORD}", "name": "user1" }],
            "congestion_control": "bbr",
            "tls": {
                "enabled": true,
                "certificate_path": "${CERT_Path}/cert.pem",
                "key_path": "${CERT_Path}/private.key",
                "alpn": ["h3"]
            }
        }
EOF
)
    ;;
    
    "shadowsocks")
        # Shadowsocks 2022
        METHOD="2022-blake3-aes-128-gcm"
        INBOUND_JSON=$(cat <<EOF
        {
            "type": "shadowsocks",
            "tag": "ss-in",
            "listen": "${LISTEN_IP}",
            "listen_port": ${PORT},
            "method": "${METHOD}",
            "password": "${PASSWORD}"
        }
EOF
)
    ;;
    *)
        echo -e "${RED}[Error] 不支持的协议: ${NODE_TYPE}${NC}"
        exit 1
    ;;
esac

# --- 6. 写入完整配置文件 ---
echo -e "${GREEN}[Step 3] 生成配置文件 (${NODE_TYPE})...${NC}"

cat > ${CONFIG_FILE} <<EOF
{
  "log": { "level": "info", "timestamp": true },
  ${DNS_CONFIG}
  "inbounds": [
    ${INBOUND_JSON}
  ],
  "outbounds": [{ "type": "direct", "tag": "direct" }]
}
EOF

# --- 7. 启动管理 ---
echo -e "${GREEN}[Step 4] 启动服务...${NC}"
RUN_CMD="${INSTALL_PATH} run -c ${CONFIG_FILE}"

if command -v systemctl >/dev/null 2>&1 && pidof systemd >/dev/null 2>&1; then
    # Systemd 模式
cat > /etc/systemd/system/sing-box.service <<EOF
[Unit]
Description=sing-box service
After=network.target

[Service]
ExecStart=${RUN_CMD}
Restart=on-failure
LimitNOFILE=infinity

[Install]
WantedBy=multi-user.target
EOF
    systemctl daemon-reload
    systemctl enable sing-box
    systemctl.restart sing-box 2>/dev/null || systemctl restart sing-box
else
    # Docker/容器模式：仅提示，不阻塞脚本结束
    echo -e "${YELLOW}[Warning] 无 Systemd 环境，请使用以下命令启动:${NC}"
    echo -e "${GREEN}${RUN_CMD} &${NC}"
fi

# --- 8. 生成并输出可导入 v2rayN 的链接 ---
# 说明：
# - vmess: 生成 vmess://<base64(JSON)> 格式（v2rayN/大多数客户端支持）
# - vless (现实): 生成 vless://... 形式，包含 reality 的 pbk/sid 参数，供 v2rayN/v2rayNG/其它支持 reality 的客户端导入
# - shadowsocks: 生成 ss://base64(method:password)@host:port#tag
# - tuic: 大多数传统 v2ray 客户端（v2rayN）不支持 TUIC，因此不生成导入链接，仅输出配置项

# 服务器（客户端导入时使用的地址）
HOST_FOR_CLIENT="${SERVER_DOMAIN}"

# VLESS/VMess 需要的变量可能已经在上面生成（PUBLIC_KEY/SHORT_ID/UUID/PASSWORD）

# 生成链接（按类型输出）
echo -e "\n=================================================="
echo -e "         ${GREEN}Sing-box 配置完成: ${NODE_TYPE}${NC}"
echo -e "=================================================="
echo -e "端口: ${PORT}"
echo -e "UUID: ${YELLOW}${UUID}${NC}"

if [ "$NODE_TYPE" == "vless" ]; then
    echo -e "类型: VLESS + Reality + Vision"
    echo -e "Public Key: ${YELLOW}${PUBLIC_KEY}${NC}"
    echo -e "Short ID: ${YELLOW}${SHORT_ID}${NC}"
    echo -e "Domain/IP: ${HOST_FOR_CLIENT}"

    # URL encode 公钥和 short id
    PBK_ENC=$(urlencode "${PUBLIC_KEY}")
    SID_ENC=$(urlencode "${SHORT_ID}")

    # vless URL（尽可能符合 v2rayN/标准）：
    # vless://UUID@host:port?encryption=none&security=reality&pbk=PUBLIC_KEY&sid=SHORT_ID&flow=xtls-rprx-vision#tag
    VLESS_URI="vless://${UUID}@${HOST_FOR_CLIENT}:${PORT}?encryption=none&security=reality&pbk=${PBK_ENC}&sid=${SID_ENC}&flow=xtls-rprx-vision#sing-box"

    echo -e "\n[可导入 v2rayN 的 VLESS (Reality) 链接]"
    echo -e "${VLESS_URI}"

elif [ "$NODE_TYPE" == "vmess" ]; then
    echo -e "类型: VMess + WS"
    echo -e "Path: ${WS_PATH}"
    if [ "$ENABLE_TLS" = true ]; then
        echo -e "TLS : ${GREEN}Enabled (自签名/指定证书)${NC}"
        echo -e "注意: 客户端需开启 allowInsecure (如果使用自签名)"
    else
        echo -e "TLS : ${RED}Disabled${NC}"
    fi

    # 构造 vmess JSON（v2ray 标准字段）
    VMESS_JSON=$(cat <<EOF
{
  "v":"2",
  "ps":"sing-box",
  "add":"${HOST_FOR_CLIENT}",
  "port":"${PORT}",
  "id":"${UUID}",
  "aid":"0",
  "net":"ws",
  "type":"none",
  "host":"",
  "path":"${WS_PATH}",
  "tls":"$( [ "$ENABLE_TLS" = true ] && echo "tls" || echo "" )"
}
EOF
)
    VMESS_URI="vmess://$(b64 "${VMESS_JSON}")"

    echo -e "\n[可导入 v2rayN 的 VMess 链接]"
    echo -e "${VMESS_URI}"

elif [ "$NODE_TYPE" == "tuic" ]; then
    echo -e "类型: TUIC V5 (QUIC)"
    echo -e "Password: ${YELLOW}${PASSWORD}${NC}"
    echo -e "注意: TUIC 强制使用 TLS，已生成自签名证书。"
    echo -e "客户端请开启 allowInsecure 选项。"

    # 按你提供的新格式生成可分享的 TUIC 链接（使用 ifconfig.me 获取公网 IP，sni 使用 SERVER_DOMAIN）
    # link="tuic://${uuid}:${passwd}@$(curl ifconfig.me):443?sni=$server_name&alpn=h3&congestion_control=bbr"
    TUIC_HOST="$(curl -s ifconfig.me || echo ${HOST_FOR_CLIENT})"
    TUIC_LINK="tuic://${UUID}:${PASSWORD}@${TUIC_HOST}:443?sni=${SERVER_DOMAIN}&alpn=h3&congestion_control=bbr"

    echo -e "
[可导入/分享的 TUIC 链接（新格式）]"
    echo -e "${TUIC_LINK}"

    echo -e "
[提示] 请确保客户端已支持 TUIC，并根据需要开启 allowInsecure（若使用自签名证书）。"

elif [ "$NODE_TYPE" == "shadowsocks" ]; then
    echo -e "Password: ${YELLOW}${PASSWORD}${NC}"
    echo -e "Method: ${METHOD}"

    # ss 链接: ss://base64(method:password)@host:port#tag
    SS_PART=$(b64 "${METHOD}:${PASSWORD}")
    SS_URI="ss://${SS_PART}@${HOST_FOR_CLIENT}:${PORT}#sing-box"

    echo -e "\n[可导入 v2rayN 的 Shadowsocks 链接]"
    echo -e "${SS_URI}"
fi

echo -e "=================================================="

# 输出配置文件路径便于手动查看
echo -e "配置文件: ${CONFIG_FILE}"
echo -e "证书目录: ${CERT_Path} (如使用 TLS/TUIC)"
echo -e "=================================================="

# 结束
exit 0
