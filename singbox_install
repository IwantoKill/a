#!/usr/bin/env bash
set -euo pipefail
# install_singbox_acme_fixed.sh
# Non-interactive installer for sing-box (improved)
# - avoids re-downloading same version
# - attempts ACME (acme.sh -> certbot) when --tls true and --domain provided
# - forces vmess to use ws transport; tls optional
# - writes client import URI to /etc/profile.d/singbox_env.sh and /etc/sing-box/client_info.txt
# - obtains PUBLIC IP for client URIs via: curl -s ipconfig.me (fallbacks included)
#
# Usage example:
# sudo bash install_singbox_acme_fixed.sh --protocol vmess --domain example.com --tls true --port 443 --dns 1.1.1.1,8.8.4.4

# ---------- config ----------
RELEASE_URL="https://github.com/SagerNet/sing-box/releases/download/v1.12.13/sing-box-1.12.13-linux-amd64.tar.gz"
DESIRED_VERSION="1.12.13"
BIN_DEST="/usr/local/bin/sing-box"
CONFIG_DIR="/etc/sing-box"
CONFIG_FILE="${CONFIG_DIR}/config.json"
DATA_DIR="/var/lib/sing-box"
SERVICE_FILE="/etc/systemd/system/sing-box.service"
LOG_FILE="/var/log/sing-box.log"
ENV_FILE="/etc/profile.d/singbox_env.sh"
CLIENT_INFO="${CONFIG_DIR}/client_info.txt"

# ---------- defaults ----------
PROTOCOL="vmess"
DOMAIN=""
TLS="false"
PORT=""
DNS_LIST=""

print_usage(){
  cat <<EOF
Usage: $0 [--protocol tuic|ss|vmess|vless] [--domain example.com] [--tls true|false] [--port PORT] [--dns 1.1.1.1,8.8.4.4]

Example:
  sudo $0 --protocol vmess --domain example.com --tls true --port 443 --dns 1.1.1.1,8.8.4.4
EOF
}

# ---------- args ----------
while [[ $# -gt 0 ]]; do
  case "$1" in
    --protocol|-p) PROTOCOL="$2"; shift 2;;
    --domain|-d) DOMAIN="$2"; shift 2;;
    --tls|-t) TLS="$2"; shift 2;;
    --port|-P) PORT="$2"; shift 2;;
    --dns|-D) DNS_LIST="$2"; shift 2;;
    --help|-h) print_usage; exit 0;;
    *) echo "Unknown arg: $1"; print_usage; exit 1;;
  esac
done
PROTOCOL=$(echo "$PROTOCOL" | tr '[:upper:]' '[:lower:]')
TLS=$(echo "$TLS" | tr '[:upper:]' '[:lower:]')
if ! echo "tuic ss vmess vless" | grep -qw "$PROTOCOL"; then
  echo "Unsupported protocol: $PROTOCOL"; exit 1
fi

# default port choices
if [ -z "$PORT" ]; then
  if [ "$TLS" = "true" ]; then PORT=443; else
    case "$PROTOCOL" in
      ss) PORT=8388;;
      tuic) PORT=8530;;
      vmess|vless) PORT=80;;
      *) PORT=443;;
    esac
  fi
fi

# ---------- helpers ----------
log(){ echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] $*"; }

gen_uuid(){
  if [ -r /proc/sys/kernel/random/uuid ]; then cat /proc/sys/kernel/random/uuid; return; fi
  if command -v uuidgen >/dev/null 2>&1; then uuidgen; return; fi
  if command -v python3 >/dev/null 2>&1; then python3 - <<'PY'
import uuid
print(uuid.uuid4())
PY
  return; fi
  if command -v openssl >/dev/null 2>&1; then
    hex=$(openssl rand -hex 16)
    printf '%s-%s-%s-%s-%s\n' "${hex:0:8}" "${hex:8:4}" "${hex:12:4}" "${hex:16:4}" "${hex:20:12}"
    return
  fi
  date +%s%N | sha256sum | cut -c1-32 | awk '{print substr($0,1,8)"-"substr($0,9,4)"-"substr($0,13,4)"-"substr($0,17,4)"-"substr($0,21)}'
}
gen_password(){
  if command -v openssl >/dev/null 2>&1; then openssl rand -base64 12; return; fi
  head -c 24 /dev/urandom | base64 | tr -d '\n' | cut -c1-16
}

get_installed_version(){
  if [ ! -x "$BIN_DEST" ]; then
    echo ""
    return
  fi
  for flag in "version" "--version" "-v" "-V"; do
    out=$("$BIN_DEST" $flag 2>/dev/null || true)
    if [ -n "$out" ]; then
      ver=$(printf '%s' "$out" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n1 || true)
      if [ -n "$ver" ]; then echo "$ver"; return; fi
    fi
  done
  echo ""
}

# ---------- binary install (skip if same version present) ----------
install_binary(){
  installed_ver="$(get_installed_version || true)"
  if [ -n "$installed_ver" ] && [ "$installed_ver" = "$DESIRED_VERSION" ]; then
    log "Found existing sing-box (${installed_ver}) at ${BIN_DEST}; skipping download."
    return
  fi

  if [ -x "$BIN_DEST" ] && [ -n "$installed_ver" ] && [ "$installed_ver" != "$DESIRED_VERSION" ]; then
    ts=$(date -u +%Y%m%dT%H%M%SZ)
    bak="${BIN_DEST}.bak-${installed_ver}-${ts}"
    log "Backing up existing binary to ${bak}"
    cp "$BIN_DEST" "$bak" || true
  fi

  tmpdir=$(mktemp -d)
  trap 'rm -rf "$tmpdir"' EXIT
  log "Downloading sing-box..."
  if command -v curl >/dev/null 2>&1; then
    curl -fsSL "$RELEASE_URL" -o "${tmpdir}/sing-box.tar.gz"
  elif command -v wget >/dev/null 2>&1; then
    wget -qO "${tmpdir}/sing-box.tar.gz" "$RELEASE_URL"
  else
    echo "curl or wget required to download binary. Abort."; exit 1
  fi
  mkdir -p "${tmpdir}/x"
  tar -xzf "${tmpdir}/sing-box.tar.gz" -C "${tmpdir}/x"
  exe_path=$(find "${tmpdir}/x" -type f -iname 'sing-box' -perm /111 | head -n1 || true)
  if [ -z "$exe_path" ]; then
    exe_path=$(find "${tmpdir}/x" -type f -iname '*sing-box*' -perm /111 | head -n1 || true)
  fi
  if [ -z "$exe_path" ]; then
    echo "Could not find sing-box executable in archive. Abort."
    ls -la "${tmpdir}/x" || true
    exit 1
  fi
  mkdir -p "$(dirname "$BIN_DEST")"
  cp "$exe_path" "$BIN_DEST"
  chmod +x "$BIN_DEST"
  log "Installed sing-box -> ${BIN_DEST}"
}

# ---------- prepare dirs + user ----------
prepare_dirs_and_user(){
  log "Preparing directories..."
  mkdir -p "$CONFIG_DIR" "$DATA_DIR" "$(dirname "$LOG_FILE")"
  if command -v useradd >/dev/null 2>&1; then
    if ! id -u singbox >/dev/null 2>&1; then
      useradd --system --no-create-home --shell /usr/sbin/nologin singbox || true
    fi
  fi
}

# ---------- ACME attempt (acme.sh -> certbot) ----------
acme_obtain_cert(){
  if [ -z "$DOMAIN" ]; then log "No domain; skip ACME"; return 1; fi

  # try acme.sh
  if ! command -v acme.sh >/dev/null 2>&1; then
    log "Installing acme.sh..."
    if command -v curl >/dev/null 2>&1; then
      curl -sSLo /tmp/acme_install.sh https://get.acme.sh || true
      SHELL=/bin/bash CHRONO=1 /bin/bash /tmp/acme_install.sh --home ~/.acme.sh || true
      rm -f /tmp/acme_install.sh
    elif command -v wget >/dev/null 2>&1; then
      wget -qO /tmp/acme_install.sh https://get.acme.sh || true
      SHELL=/bin/bash CHRONO=1 /bin/bash /tmp/acme_install.sh --home ~/.acme.sh || true
      rm -f /tmp/acme_install.sh
    fi
  fi

  ACME_BIN=""
  if command -v acme.sh >/dev/null 2>&1; then ACME_BIN=$(command -v acme.sh); fi
  if [ -z "$ACME_BIN" ] && [ -f "$HOME/.acme.sh/acme.sh" ]; then ACME_BIN="$HOME/.acme.sh/acme.sh"; fi

  if [ -n "$ACME_BIN" ]; then
    log "Using acme.sh to issue certificate for ${DOMAIN} (standalone)..."
    "${ACME_BIN}" --issue -d "${DOMAIN}" --standalone --force >/dev/null 2>&1 || true
    if "${ACME_BIN}" --install-cert -d "${DOMAIN}" --key-file "${CONFIG_DIR}/key.pem" --fullchain-file "${CONFIG_DIR}/cert.pem" >/dev/null 2>&1; then
      chmod 600 "${CONFIG_DIR}/key.pem" || true
      chmod 644 "${CONFIG_DIR}/cert.pem" || true
      log "acme.sh obtained certificate for ${DOMAIN}"
      return 0
    else
      log "acme.sh issue/install failed (standalone)."
    fi
  fi

  # fallback: certbot
  if ! command -v certbot >/dev/null 2>&1; then
    log "Attempting to install certbot (apt/yum/dnf) if available..."
    if command -v apt-get >/dev/null 2>&1; then
      apt-get update -qq || true
      DEBIAN_FRONTEND=noninteractive apt-get install -y -qq certbot || true
    elif command -v yum >/dev/null 2>&1; then
      yum install -y -q certbot || true
    elif command -v dnf >/dev/null 2>&1; then
      dnf install -y -q certbot || true
    fi
  fi

  if command -v certbot >/dev/null 2>&1; then
    log "Using certbot (standalone) to request certificate for ${DOMAIN}..."
    certbot certonly --non-interactive --agree-tos --register-unsafely-without-email --standalone -d "${DOMAIN}" >/dev/null 2>&1 || true
    if [ -f "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" ] && [ -f "/etc/letsencrypt/live/${DOMAIN}/privkey.pem" ]; then
      cp "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" "${CONFIG_DIR}/cert.pem"
      cp "/etc/letsencrypt/live/${DOMAIN}/privkey.pem" "${CONFIG_DIR}/key.pem"
      chmod 600 "${CONFIG_DIR}/key.pem" || true
      chmod 644 "${CONFIG_DIR}/cert.pem" || true
      log "certbot obtained certificate for ${DOMAIN}"
      return 0
    else
      log "certbot did not produce expected files."
    fi
  fi

  return 1
}

# ---------- self-signed cert ----------
generate_self_signed_cert(){
  CERT_PATH="${CONFIG_DIR}/cert.pem"
  KEY_PATH="${CONFIG_DIR}/key.pem"
  if [ -f "$CERT_PATH" ] && [ -f "$KEY_PATH" ]; then log "Certs already exist"; return 0; fi
  if ! command -v openssl >/dev/null 2>&1; then echo "openssl required for self-signed cert"; return 1; fi
  CN="${DOMAIN:-$(hostname -f 2>/dev/null || hostname)}"
  log "Generating self-signed cert for CN=${CN}"
  openssl req -x509 -nodes -days 3650 -newkey rsa:2048 -keyout "$KEY_PATH" -out "$CERT_PATH" -subj "/CN=${CN}" >/dev/null 2>&1
  chmod 600 "$KEY_PATH" || true
  chmod 644 "$CERT_PATH" || true
}

# ---------- build config ----------
build_config(){
  UUID=$(gen_uuid)
  PASSWORD=$(gen_password)
  METHOD="2022-blake3-aes-128-gcm"
  LISTEN_PORT="$PORT"

  DNS_BLOCK=""
  if [ -n "$DNS_LIST" ]; then
    IFS=',' read -r -a dns_arr <<< "$DNS_LIST"
    dns_servers_json=""
    for d in "${dns_arr[@]}"; do
      d_trimmed=$(echo "$d" | xargs)
      dns_servers_json="${dns_servers_json}{\"address\":\"${d_trimmed}\"},"
    done
    dns_servers_json="[${dns_servers_json%,}]"
    DNS_BLOCK=",\"dns\": { \"servers\": ${dns_servers_json} }"
  fi

  LOG_BLOCK='  "log": { "level": "info", "timestamp": true }'
  INBOUND_JSON=""
  case "$PROTOCOL" in
    vmess)
      WS_PATH="/ws-${UUID}"
      TLS_JSON=""
      if [ "$TLS" = "true" ]; then TLS_JSON=",\"tls\": { \"enabled\": true }"; fi
      INBOUND_JSON=$(cat <<JSON
{
  "type": "vmess",
  "tag": "vmess-in",
  "listen": "0.0.0.0",
  "listen_port": ${LISTEN_PORT},
  "tcp_fast_open": false,
  "users": [
    { "uuid": "${UUID}", "alterId": 0 }
  ],
  "transport": { "type": "ws", "path": "${WS_PATH}" }${TLS_JSON}
}
JSON
)
      ;;
    vless)
      TLS_JSON=""
      if [ "$TLS" = "true" ]; then TLS_JSON=",\"tls\": { \"enabled\": true }"; fi
      INBOUND_JSON=$(cat <<JSON
{
  "type": "vless",
  "tag": "vless-in",
  "listen": "0.0.0.0",
  "listen_port": ${LISTEN_PORT},
  "tcp_fast_open": false,
  "users": [ { "uuid": "${UUID}" } ]${TLS_JSON}
}
JSON
)
      ;;
    ss)
      INBOUND_JSON=$(cat <<JSON
{
  "type": "shadowsocks",
  "tag": "ss-in",
  "listen": "0.0.0.0",
  "listen_port": ${LISTEN_PORT},
  "network": "tcp",
  "method": "${METHOD}",
  "password": "${PASSWORD}",
  "multiplex": { "enabled": true }
}
JSON
)
      ;;
    tuic)
      TUIC_PW=$(gen_password)
      INBOUND_JSON=$(cat <<JSON
{
  "type": "tuic",
  "tag": "tuic-in",
  "listen": "0.0.0.0",
  "listen_port": ${LISTEN_PORT},
  "users": [ { "uuid": "${UUID}", "password": "${TUIC_PW}" } ]
}
JSON
)
      ;;
  esac

  OUTBOUND_JSON='[ { "type": "direct", "tag": "direct" }, { "type": "block", "tag": "block" } ]'

  CERT_BLOCK=""
  if [ "$TLS" = "true" ]; then
    if [ ! -f "${CONFIG_DIR}/cert.pem" ] || [ ! -f "${CONFIG_DIR}/key.pem" ]; then
      log "TLS requested - attempting ACME..."
      if acme_obtain_cert; then
        log "ACME succeeded"
      else
        log "ACME failed; generating self-signed cert"
        generate_self_signed_cert
      fi
    fi
    CERT_BLOCK=",\"certificate\": { \"local_certificates\": [ { \"cert\": \"${CONFIG_DIR}/cert.pem\", \"key\": \"${CONFIG_DIR}/key.pem\", \"names\": [\"${DOMAIN:-$(hostname)}\"] } ] }"
  fi

  cat > "$CONFIG_FILE" <<JSON
{
${LOG_BLOCK}${DNS_BLOCK}${CERT_BLOCK},
  "inbounds": [
    ${INBOUND_JSON}
  ],
  "outbounds": ${OUTBOUND_JSON}
}
JSON

  chmod 644 "$CONFIG_FILE" || true
  log "Wrote config -> ${CONFIG_FILE}"
}

# ---------- setup service ----------
setup_service(){
  if id -u singbox >/dev/null 2>&1; then
    chown -R singbox:singbox "${CONFIG_DIR}" "${DATA_DIR}" || true
    chown singbox:singbox "${LOG_FILE}" 2>/dev/null || true
  fi

  if command -v "$BIN_DEST" >/dev/null 2>&1; then
    log "Running sing-box check -c ${CONFIG_FILE} (one-time check)"
    "$BIN_DEST" check -c "${CONFIG_FILE}" || log "sing-box check returned non-zero (continuing)"
  fi

  if command -v systemctl >/dev/null 2>&1 && [ -d /run/systemd/system ]; then
    log "Installing systemd unit..."
    cat > "${SERVICE_FILE}" <<EOF
[Unit]
Description=sing-box Service
After=network.target nss-lookup.target
Wants=network.target

[Service]
Type=simple
User=singbox
ExecStartPre=-${BIN_DEST} check -c ${CONFIG_FILE}
ExecStart=${BIN_DEST} run -c ${CONFIG_FILE}
WorkingDirectory=${DATA_DIR}
Restart=on-failure
RestartSec=3
LimitNOFILE=65535
AmbientCapabilities=CAP_NET_BIND_SERVICE
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
NoNewPrivileges=true

[Install]
WantedBy=multi-user.target
EOF
    if ! id -u singbox >/dev/null 2>&1; then
      sed -i '/^User=singbox$/d' "${SERVICE_FILE}" || true
    fi
    systemctl daemon-reload || true
    systemctl enable --now sing-box.service || true
    systemctl restart sing-box.service | systemctl start sing-box.service
    log "systemd configured; check status: systemctl status sing-box"
  else
    START_SCRIPT="/usr/local/bin/singbox_run.sh"
    log "No systemd: creating ${START_SCRIPT} and launching with nohup"
    cat > "${START_SCRIPT}" <<EOF
#!/usr/bin/env bash
exec ${BIN_DEST} run -c ${CONFIG_FILE} >> "${LOG_FILE}" 2>&1
EOF
    chmod +x "${START_SCRIPT}"
    setsid nohup "${START_SCRIPT}" >/dev/null 2>&1 &
    sleep 1
    if command -v crontab >/dev/null 2>&1; then
      (crontab -l 2>/dev/null || true; echo "@reboot ${START_SCRIPT} >/dev/null 2>&1 &") | crontab -
      log "Added @reboot crontab"
    fi
  fi
}

# ---------- get public ip (ipconfig.me as requested), fallback to wget or ifconfig/hostname ----------
get_public_ip(){
  ip=""
  if command -v curl >/dev/null 2>&1; then
    ip=$(curl ifconfig.me || true)
  fi
  if [ -z "$ip" ] && command -v wget >/dev/null 2>&1; then
    ip=$(wget -qO- --timeout=5 https://ipconfig.me || true)
  fi
  if [ -z "$ip" ]; then
    # fallback to other services
    if command -v curl >/dev/null 2>&1; then
      ip=$(curl -s --max-time 5 ifconfig.me || true)
    fi
  fi
  if [ -z "$ip" ]; then
    # fallback to local
    ip=$(hostname -I 2>/dev/null | awk '{print $1}' || true)
  fi
  if [ -z "$ip" ]; then ip="127.0.0.1"; fi
  printf '%s' "$ip"
}

# ---------- build client URIs, write env + client_info ----------
build_client_info_and_env(){
  # Use public IP (from ipconfig.me) when no domain provided
  if [ -n "$DOMAIN" ]; then
    HOST="${DOMAIN}"
  else
    HOST="$(get_public_ip)"
  fi

  if [ "$PROTOCOL" = "vmess" ]; then
    WS_PATH="/ws-${UUID}"
    vmess_json=$(cat <<JSON
{
  "v":"2",
  "ps":"sing-box-${HOST}",
  "add":"${HOST}",
  "port":"${PORT}",
  "id":"${UUID}",
  "aid":"0",
  "net":"ws",
  "type":"none",
  "host":"",
  "path":"${WS_PATH}",
  "tls":"$( [ "$TLS" = "true" ] && echo "tls" || echo "" )"
}
JSON
)
    vmess_base=$(printf '%s' "${vmess_json}" | openssl base64 -A)
    CONN_URI="vmess://${vmess_base}"
  elif [ "$PROTOCOL" = "vless" ]; then
    QS="type=tcp"
    if [ "$TLS" = "true" ]; then QS="${QS}&security=tls"; fi
    CONN_URI="vless://${UUID}@${HOST}:${PORT}?${QS}#sing-box"
  elif [ "$PROTOCOL" = "ss" ]; then
    CRED="${METHOD}:${PASSWORD}"
    CRED_B64=$(printf '%s' "${CRED}" | openssl base64 -A)
    CONN_URI="ss://${CRED_B64}@${HOST}:${PORT}#sing-box"
  elif [ "$PROTOCOL" = "tuic" ]; then
    CONN_URI="tuic://user=${UUID};pass=${TUIC_PW}@${HOST}:${PORT}"
  else
    CONN_URI=""
  fi

  cat > "${ENV_FILE}" <<EOF
# sing-box client env (auto-generated)
export SINGBOX_PROTOCOL="${PROTOCOL}"
export SINGBOX_HOST="${HOST}"
export SINGBOX_PORT="${PORT}"
export SINGBOX_TLS="${TLS}"
export SINGBOX_DOMAIN="${DOMAIN}"
export SINGBOX_CONN="${CONN_URI}"
export SINGBOX_CONFIG="${CONFIG_FILE}"
export SINGBOX_CERT="${CONFIG_DIR}/cert.pem"
export SINGBOX_KEY="${CONFIG_DIR}/key.pem"
EOF
  chmod 644 "${ENV_FILE}" || true

  cat > "${CLIENT_INFO}" <<EOF
sing-box client info
--------------------
Protocol: ${PROTOCOL}
Host: ${HOST}
Port: ${PORT}
TLS: ${TLS}
Domain: ${DOMAIN:-<none>}

Connection URI (one-line import):
${CONN_URI}

Note: env exports -> ${ENV_FILE}
To load now: source ${ENV_FILE} && echo "\$SINGBOX_CONN"
EOF
  chmod 644 "${CLIENT_INFO}" || true

  # Print import link once for convenience
  cat <<OUT

==================== 导入链接（已打印） ====================
${CONN_URI}
========================================================

Config: ${CONFIG_FILE}
Client info: ${CLIENT_INFO}
Env file: ${ENV_FILE}  (source it to see \$SINGBOX_CONN)
OUT
}

# ---------- main ----------
log "Starting sing-box installer (finalized)..."
install_binary
prepare_dirs_and_user

# TLS: attempt ACME (if domain provided) else self-signed if tls requested
if [ "$TLS" = "true" ]; then
  if [ -n "$DOMAIN" ]; then
    log "Attempting ACME for domain ${DOMAIN}..."
    if acme_obtain_cert; then
      log "ACME succeeded"
    else
      log "ACME failed; falling back to self-signed cert"
      generate_self_signed_cert
    fi
  else
    log "TLS requested but no domain provided -> generating self-signed cert"
    generate_self_signed_cert
  fi
fi

build_config

# ensure config/key readable by service user
if id -u singbox >/dev/null 2>&1; then
  chown -R singbox:singbox "${CONFIG_DIR}" "${DATA_DIR}" || true
  chmod 600 "${CONFIG_DIR}/key.pem" 2>/dev/null || true
fi

setup_service
build_client_info_and_env

log "Done. If systemd is present run: systemctl status sing-box"
exit 0
